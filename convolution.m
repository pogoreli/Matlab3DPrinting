clear
clc

filename = "img3.jpg";
img = imread(filename);

thumbnail = getBase64(img);

img_resized = imresize(img, [2000, 2000]);
contour = getContour(img_resized);
img_filtered = removeSmallGroups(contour, 20);

% background = ones(size(img_filtered));
% backgroundGroup = identifyGroups(background);
% backgroundPath = planPath(backgroundGroup);
backgroundPath = struct2cell(load("backgroundPath.mat"));


groups = identifyGroups(img_filtered);
path = planPath(groups);

writeToFile(thumbnail, backgroundPath, path, 'model_1');

figure
x = cellfun(@(c) c(1), path);
y = cellfun(@(c) c(2), path);
plot(x, y, 'r+', 'MarkerSize', 1, 'LineWidth', 2);





% % centroids = calculateCentroids(groups);
% % topPoints = findTopPoints(groups);
% % topPoint1 = findTopPoint(groups{35})
% % path = planPathGroup(groups{8});
% figure
% % imshowpair(img, contour, 'montage')
% % figure
% % imshow(contour)
% % hold on;
% % 
% x = cellfun(@(c) c(1), path);
% y = cellfun(@(c) c(2), path);
% 
% plot(x, y, 'r+', 'MarkerSize', 10, 'LineWidth', 2);
% % hold off;

% length(groups{14})
% connectGroups(contour);
% imshow(img_imbinarize)

function writeToFile(thumbnail, backgroundPath, imagePath, modelName)
    fileID = fopen([modelName, '.gcode'], 'w');

    currentDate = datetime('now', 'Format', 'yyyy-MM-dd');
    currentTime = datetime('now', 'Format', 'HH:mm:ss');
    currentTimeZone = datetime('now', 'TimeZone', 'local').TimeZone;
    formattedString = sprintf('; Generated by convolution.m Independent study John Pogorelov on %s at %s %s', currentDate, currentTime, currentTimeZone);
    fprintf(fileID, '%s\n', formattedString);
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', ';');
    fprintf(fileID, '%s\n', '; thumbnail begin 160x120 5860');

    lines = separateLines(thumbnail, 78);
    for i=1:length(lines)
        % formattedString = sprintf('; %s', lines(i));
        formattedString = sprintf('; %s', string(lines(i)));

        fprintf(fileID, '%s\n', formattedString);
    end
    
    fprintf(fileID, '%s\n', '; thumbnail end');
    fprintf(fileID, '%s\n', ';');
    fprintf(fileID, '%s\n', ';');
    fprintf(fileID, '%s\n', '');


    fprintf(fileID, '%s\n', '; external perimeters extrusion width = 0.45mm');
    fprintf(fileID, '%s\n', '; perimeters extrusion width = 0.45mm');
    fprintf(fileID, '%s\n', '; infill extrusion width = 0.45mm');
    fprintf(fileID, '%s\n', '; solid infill extrusion width = 0.45mm');
    fprintf(fileID, '%s\n', '; top infill extrusion width = 0.40mm');
    fprintf(fileID, '%s\n', '; first layer extrusion width = 0.42mm');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', 'M73 P0 R8446');
    fprintf(fileID, '%s\n', 'M73 Q0 S9909');
    fprintf(fileID, '%s\n', 'M201 X1000 Y1000 Z200 E5000 ; sets maximum accelerations, mm/sec^2');
    fprintf(fileID, '%s\n', 'M203 X200 Y200 Z12 E120 ; sets maximum feedrates, mm / sec');
    fprintf(fileID, '%s\n', 'M204 S1250 T1250 ; sets acceleration (S) and retract acceleration (R), mm/sec^2');
    fprintf(fileID, '%s\n', 'M205 X8.00 Y8.00 Z0.40 E4.50 ; sets the jerk limits, mm/sec');
    fprintf(fileID, '%s\n', 'M205 S0 T0 ; sets the minimum extruding and travel feed rate, mm/sec');
    fprintf(fileID, '%s\n', ';TYPE:Custom');
    fprintf(fileID, '%s\n', 'M862.3 P "MK3S" ; printer model check');
    fprintf(fileID, '%s\n', 'M862.1 P0.4 ; nozzle diameter check');
    fprintf(fileID, '%s\n', 'M115 U3.12.2 ; tell printer latest fw version');
    fprintf(fileID, '%s\n', 'G90 ; use absolute coordinates');
    fprintf(fileID, '%s\n', 'M83 ; extruder relative mode');
    fprintf(fileID, '%s\n', 'M104 S215 ; set extruder temp');
    fprintf(fileID, '%s\n', 'M140 S60 ; set bed temp');
    fprintf(fileID, '%s\n', 'M190 S60 ; wait for bed temp');
    fprintf(fileID, '%s\n', 'M109 S215 ; wait for extruder temp');
    fprintf(fileID, '%s\n', 'G28 W ; home all without mesh bed level');
    fprintf(fileID, '%s\n', 'G80 ; mesh bed leveling');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', 'G1 Z0.2 F720');
    fprintf(fileID, '%s\n', 'G1 Y-3 F1000 ; go outside print area');
    fprintf(fileID, '%s\n', 'G92 E0');
    fprintf(fileID, '%s\n', 'G1 X60 E9 F1000 ; intro line');
    fprintf(fileID, '%s\n', 'G1 X100 E12.5 F1000 ; intro line');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', 'G92 E0');
    fprintf(fileID, '%s\n', 'M221 S95');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', '; Do not change E values below. Excessive value can damage the printer.');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', 'M907 E538 ; set extruder motor current');
    fprintf(fileID, '%s\n', 'G21 ; set units to millimeters');
    fprintf(fileID, '%s\n', 'G90 ; use absolute coordinates');
    fprintf(fileID, '%s\n', 'M83 ; use relative distances for extrusion');
    fprintf(fileID, '%s\n', 'M900 K0.05 ; Filament gcode LA 1.5');
    fprintf(fileID, '%s\n', 'M900 K30 ; Filament gcode LA 1.0');
    fprintf(fileID, '%s\n', 'M107');
    fprintf(fileID, '%s\n', ';LAYER_CHANGE');
    fprintf(fileID, '%s\n', ';Z:0.2');
    fprintf(fileID, '%s\n', ';HEIGHT:0.2');
    fprintf(fileID, '%s\n', ';BEFORE_LAYER_CHANGE');
    fprintf(fileID, '%s\n', 'G92 E0.0');
    fprintf(fileID, '%s\n', ';0.2');

    fprintf(fileID, '%s\n', 'G1 E-.8 F2100');
    fprintf(fileID, '%s\n', 'G1 Z.4 F720');
    fprintf(fileID, '%s\n', 'G1 X36.115 Y11.393 F10800');
    fprintf(fileID, '%s\n', 'G1 Z.2 F720');
    fprintf(fileID, '%s\n', 'G1 E.8 F2100');
    fprintf(fileID, '%s\n', 'M204 S800');

    fprintf(fileID, '%s\n', 'G1 Z.2 F1200');

    for i = 1:length(backgroundPath{1})
        X = 
        formattedString = sprintf('; Generated by convolution.m Independent study John Pogorelov on %s at %s %s', currentDate, currentTime, currentTimeZone);
        fprintf(fileID, '%s\n', string(i));

    end
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', '');
    fprintf(fileID, '%s\n', '');
    
    fclose(fileID);

end

function base64 = getBase64(image)
    disp('converting image to Base64');
    img_resized = imresize(image, [120, 160]);
    imwrite(img_resized, 'temp_image_file.jpg');
    fid = fopen('temp_image_file.jpg','rb');
    bytes = fread(fid);
    fclose(fid);
    encoder = org.apache.commons.codec.binary.Base64;
    base64arr = char(encoder.encode(bytes))';
    base64str = string(base64arr);
    base64 = base64str(1);
end

function output = separateLines(inputString, interval)
    disp('inserting new lines')
    n = strlength(inputString);
    output = {''};
    index = 1;
    for i = 1:interval:n
        endIndex = min(i+interval-1, n);
        output{index} = extractBetween(inputString, i, endIndex);
        index = index + 1;
    end
end

function path = planPath(groups)
    disp('planning the path')
    path = {};
    for i = 1:length(groups)
        path = [path, planPathGroup(groups{i})];
    end
end

function path = planPathGroup(group)
    disp('planning the path for a group')
    points = group;
    visited = zeros(length(points));

    path = {};
    firstPoint = (findTopPoint(points));
    path{end + 1} = firstPoint(1:2);
    visited(firstPoint(3)) = 1;

    currentPoint = firstPoint;
    exists = false;
    pointIndex = 0;

    for i = 1:length(points)
        nextPoint = [currentPoint(1)+1, currentPoint(2)];
        [exists, pointIndex] = pointExitst(points, visited, nextPoint);

        if(exists)
            path{end + 1} = points{pointIndex}(1:2);
            visited(pointIndex) = 1;
            currentPoint = points{pointIndex};
        else
            %%%%%%%%%%%%%%%
            nextPoint = [currentPoint(1), currentPoint(2)-1];
            [exists, pointIndex] = pointExitst(points, visited, nextPoint);
    
            if(exists)
                path{end + 1} = points{pointIndex}(1:2);
                visited(pointIndex) = 1;
                currentPoint = points{pointIndex};
            else
                %%%%%%%%%%%%%%%
                nextPoint = [currentPoint(1)-1, currentPoint(2)];
                [exists, pointIndex] = pointExitst(points, visited, nextPoint);
        
                if(exists)
                    path{end + 1} = points{pointIndex}(1:2);
                    visited(pointIndex) = 1;
                    currentPoint = points{pointIndex};
                else
                    %%%%%%%%%%%%%%%
                    nextPoint = [currentPoint(1), currentPoint(2)+1];
                    [exists, pointIndex] = pointExitst(points, visited, nextPoint);
            
                    if(exists)
                        path{end + 1} = points{pointIndex}(1:2);
                        visited(pointIndex) = 1;
                        currentPoint = points{pointIndex};
                    else
                        %%%%%%%%%%%%%%%
                        nextPoint = [currentPoint(1)+1, currentPoint(2)-1];
                        [exists, pointIndex] = pointExitst(points, visited, nextPoint);
                
                        if(exists)
                            path{end + 1} = points{pointIndex}(1:2);
                            visited(pointIndex) = 1;
                            currentPoint = points{pointIndex};
                        else
                            %%%%%%%%%%%%%%%
                            nextPoint = [currentPoint(1)+1, currentPoint(2)+1];
                            [exists, pointIndex] = pointExitst(points, visited, nextPoint);
                    
                            if(exists)
                                path{end + 1} = points{pointIndex}(1:2);
                                visited(pointIndex) = 1;
                                currentPoint = points{pointIndex};
                            else
                                %%%%%%%%%%%%%%%
                                nextPoint = [currentPoint(1)-1, currentPoint(2)-1];
                                [exists, pointIndex] = pointExitst(points, visited, nextPoint);
                        
                                if(exists)
                                    path{end + 1} = points{pointIndex}(1:2);
                                    visited(pointIndex) = 1;
                                    currentPoint = points{pointIndex};
                                else
                                    %%%%%%%%%%%%%%%
                                    nextPoint = [currentPoint(1)-1, currentPoint(2)+1];
                                    [exists, pointIndex] = pointExitst(points, visited, nextPoint);
                            
                                    if(exists)
                                        path{end + 1} = points{pointIndex}(1:2);
                                        visited(pointIndex) = 1;
                                        currentPoint = points{pointIndex};
                                    else
                                        %%%%%%%%%%%%%%%
                                        for k=1:length(visited)
                                            if(visited(k) == 0)
                                                path{end+1} = points{k}(1:2);
                                                visited(k) = 1;
                                                currentPoint = points{k};
                                            end
                                        end
                                    end
                                end
                            end
                        end
                    end
                end
            end
        end
   
    end
end

function [exists, index] = pointExitst(group, visited, point)
    disp('checking whether point exists');
    for j = 1:length(group)
        if(group{j}(1) == point(1) && group{j}(2) == point(2) && visited(j) == 0)
            exists = true;
            index = j;
            break;
        end
    end
    exists = false;
    index = 0;
end


function topPoint = findTopPoint(group)
    disp('searching for the top point in a group');
    topPoint = {};

    smallest_x = group{1}(1);
    smallest_y = group{1}(2);
    indexXY = 1;
    numPoints = length(group);
    for j = 1:numPoints
        
        current_x = group{j}(1);
        current_y = group{j}(2);
            
        if(current_y < smallest_y)
            smallest_x = current_x;
            smallest_y = current_y;
            indexXY = j;
        elseif(current_y == smallest_y)
            if(current_x < smallest_x)
                smallest_x = current_x;
                smallest_y = current_y;
                indexXY = j;
            end
        end
    end
    topPoint = [smallest_x, smallest_y, indexXY];
end

function topPoints = findTopPoints(groups)
    disp('identifying top points in groups');
    topPoints = {};

    for i = 1:length(groups)
        smallest_x = groups{i}{1}(1);
        smallest_y = groups{i}{1}(2);
        numPoints = length(groups{i});
        for j = 1:numPoints
            current_x = groups{i}{j}(1);
            current_y = groups{i}{j}(2);
            
            if(current_y < smallest_y)
                smallest_x = current_x;
                smallest_y = current_y;
            elseif(current_y == smallest_y)
                if(current_x < smallest_x)
                    smallest_x = current_x;
                    smallest_y = current_y;
                end
            end
        end

        topPoints{end + 1} = [smallest_x, smallest_y];
    end 
end


function centroids = calculateCentroids(groups)
    centroids = {};

    for i = 1:length(groups)
        x = 0;
        y = 0;
        numPoints = length(groups{i});
        for j = 1:numPoints
            x = x + groups{i}{j}(1);
            y = y + groups{i}{j}(2);
        end
        x = x / numPoints;
        y = y / numPoints;

        centroids{end + 1} = [x, y];
    end  
end


function img_filtered = removeSmallGroups(img, threshold)
    disp('removing small groups');
    img_filtered = img;
    groups = identifyGroups(img);

    for i = 1:length(groups)
        if (length(groups{i}) < threshold)
            for j = 1:length(groups{i})
                x = groups{i}{j}(1);
                y = groups{i}{j}(2);
                img_filtered(x, y) = 0;
            end
        end
    end

end


function groups = identifyGroups(img)
    disp('identifying all the groups');
    groups = {};
    visited = false(size(img));

    for i = 1:size(img, 1)
        for j = 1:size(img, 2)
            if(img(i, j) == 1 && ~visited(i,j))
                [visited, group] = dfs(img, i, j, visited, {});
                if ~isempty(group)
                    groups{end + 1} = group;
                end
            end
        end
    end

end

function [visited, group] = dfs(grid, x, y, visited, group)
    if(x < 1 || x > size(grid, 1) || y < 1 || y > size(grid, 2))
        return;
    elseif(visited(x, y) || grid(x, y) == 0)
        return;
    end

    visited(x, y) = true;
    group{end + 1} = [x, y];

    [visited, group] = dfs(grid, x+1, y, visited, group);
    [visited, group] = dfs(grid, x-1, y, visited, group);
    [visited, group] = dfs(grid, x, y+1, visited, group);
    [visited, group] = dfs(grid, x+1, y-1, visited, group);
    [visited, group] = dfs(grid, x+1, y+1, visited, group);
    [visited, group] = dfs(grid, x-1, y-1, visited, group);
    [visited, group] = dfs(grid, x+1, y-1, visited, group);
    [visited, group] = dfs(grid, x-1, y+1, visited, group);
end


function connectedGroups = connectGroups(img)
    height = length(img(:,1));
    width = length((img(1,:))');
    array = zeros(height, width, 2);
    array(:,:,1) = img;
    imshowpair(array(:,:,1), array(:,:,2), 'montage')
end



function imbinarizedImage = getContour(img)
    disp('getting the contour of the image');
    img_grayscale = rgb2gray(img);
    mask = [2, -0.1, -1; -1, 5, -1; -1, -1, -1];
    %mask = [1, -0.1, -1.5; 1, 5, -1.5; 1, -1, -1.5];
    img_imbinarize = imbinarize(img_grayscale, 0.4);
    img_conv = conv2(img_imbinarize, mask);
    imbinarizedImage = imbinarize(img_conv, 0.99);
end